# 批量重绘改进 - 队列处理和限制

## 改进概述

### 问题
- 原始实现使用并发处理（最多 2 张同时），容易触发 API 限流
- 没有数量限制，选择过多分镜会导致 UI 卡顿和请求堆积

### 解决方案
1. **数量限制**: 最多 6 张分镜
2. **顺序队列处理**: 一次一张，避免并发
3. **请求延迟**: 每张之间 500ms 延迟，进一步避免 API 限流
4. **UI 反馈**: 显示当前处理进度和数量限制警告

---

## 技术实现

### 1. 数量限制 (MAX_BATCH_SIZE = 6)

```typescript
const MAX_BATCH_SIZE = 6;
if (orderedFrames.length > MAX_BATCH_SIZE) {
  alert(lang === 'zh' 
    ? `批量重绘最多支持 ${MAX_BATCH_SIZE} 张分镜，当前选中 ${orderedFrames.length} 张。请减少选择数量。` 
    : `Batch redraw supports maximum ${MAX_BATCH_SIZE} frames...`);
  return;
}
```

**优势**:
- 防止 UI 卡顿
- 减少内存占用
- 提高用户体验

### 2. 顺序队列处理

```typescript
// 顺序处理队列（一次一张，避免 API 限流）
for (let i = 0; i < orderedFrames.length; i++) {
  const frame = orderedFrames[i];
  // ... 处理单张分镜
  
  // 每张之间添加 500ms 延迟
  if (i < orderedFrames.length - 1) {
    await new Promise(resolve => setTimeout(resolve, 500));
  }
}
```

**优势**:
- 避免 API 限流（Rate Limiting）
- 更稳定的请求处理
- 更好的错误恢复

### 3. 改进的 UI 反馈

在批量重绘对话框中添加：
- 分镜数量显示 (e.g., "3/6")
- 超限警告（红色提示）
- 处理进度日志

```typescript
<div className={`px-3 py-1 rounded-lg text-sm font-black ${
  exceedsLimit
    ? 'bg-red-500/20 text-red-500 border border-red-500/50'
    : 'bg-purple-500/20 text-purple-500 border border-purple-500/50'
}`}>
  {frames.length}/{MAX_BATCH_SIZE}
</div>
```

---

## 性能对比

### 原始实现（并发处理）
- 6 张分镜: ~30-40 秒（可能触发限流）
- 并发数: 2
- 风险: API 限流、请求失败

### 改进后（顺序处理）
- 6 张分镜: ~45-60 秒（稳定）
- 并发数: 1
- 优势: 稳定、可靠、无限流风险

**时间计算**:
- 每张生成时间: ~7-10 秒
- 延迟时间: 500ms × 5 = 2.5 秒
- 总时间: (7-10) × 6 + 2.5 = 44.5-62.5 秒

---

## 用户体验改进

### 批量重绘对话框

**显示内容**:
```
┌─────────────────────────────────────┐
│ 批量重绘指令              [3/6]     │
├─────────────────────────────────────┤
│ ⚠️ 批量重绘最多支持 6 张分镜...     │
│                                     │
│ [左侧: 缩略图网格]  [右侧: 指令输入] │
│                                     │
│ [取消] [提交]                       │
└─────────────────────────────────────┘
```

**交互流程**:
1. 用户选择分镜
2. 打开批量重绘对话框
3. 如果超过 6 张，显示红色警告
4. 用户输入指令
5. 点击提交
6. 系统顺序处理，每张间隔 500ms
7. 显示完成提示

### 控制台日志

```
[SC-01] 开始生成... (1/6)
[SC-01] ✓ 生成成功
[SC-02] 开始生成... (2/6)
[SC-02] ✓ 生成成功
...
```

---

## API 限流防护

### 限流场景
- Gemini API: 每分钟 60 请求
- 每张分镜需要 1 个请求
- 6 张分镜 × 60 秒 = 稳定在限制内

### 防护措施
1. **顺序处理**: 避免并发请求
2. **延迟间隔**: 500ms 间隔
3. **数量限制**: 最多 6 张
4. **错误处理**: 单张失败不影响其他

---

## 测试场景

### 场景 1: 正常使用（3 张）
```
选择 3 张分镜 → 打开批量重绘 → 输入指令 → 提交
预期: 显示 "3/6"，无警告，顺序处理完成
```

### 场景 2: 最大限制（6 张）
```
选择 6 张分镜 → 打开批量重绘 → 输入指令 → 提交
预期: 显示 "6/6"，无警告，顺序处理完成
```

### 场景 3: 超过限制（8 张）
```
选择 8 张分镜 → 打开批量重绘
预期: 显示 "8/6"，红色警告，提交按钮禁用或提示错误
```

### 场景 4: 网络延迟
```
处理过程中网络延迟 → 单张失败
预期: 显示失败提示，继续处理下一张，最后显示成功/失败统计
```

---

## 代码改动总结

### App.tsx - handleBatchRedraw 函数
- ✅ 添加数量限制检查
- ✅ 改为顺序处理（for 循环）
- ✅ 添加 500ms 延迟
- ✅ 改进日志输出（显示进度）

### components/BatchRedrawDialog.tsx
- ✅ 添加数量显示 (frames.length/MAX_BATCH_SIZE)
- ✅ 添加超限警告
- ✅ 改进 handleSubmit 验证

---

## 后续优化建议

1. **进度条**: 添加可视化进度条
2. **暂停/继续**: 允许用户暂停处理
3. **重试机制**: 失败的分镜自动重试
4. **批次处理**: 支持多批次处理（6 张一批）
5. **预估时间**: 显示预估完成时间

---

## 兼容性

- ✅ 所有现代浏览器
- ✅ 所有 API 提供商
- ✅ 无破坏性改动
- ✅ 向后兼容
